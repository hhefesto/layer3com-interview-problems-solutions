
==================== FINAL INTERFACE ====================
2019-12-18 21:49:02.833791789 UTC

interface main:Solutions 8065
  interface hash: bc6d1925e0813ad3a3685378c3d230fa
  ABI hash: 15b15122b70e9e9be2104f5552ad3b05
  export-list hash: a5b8b96224f2eec5e4c40dba8759c7b4
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 3511dd70d4116694195026d611330191
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Solutions.insert
  Solutions.ipv4
  Solutions.missingNumber
  Solutions.missingNumber'
  Solutions.myReadWord8
  Solutions.onlyJust
  Solutions.parse
  Solutions.possibleAddresses
  Solutions.possibleAddresses'
  Solutions.unmaybeIPv4
  Solutions.word8
  Solutions.Bin{Solutions.Leaf Solutions.Node}
  Solutions.IPv4
  Solutions.IPv4'
  Solutions.Parser{Solutions.P}
module dependencies:
package dependencies: array-0.5.3.0 base-4.12.0.0 deepseq-1.4.4.0
                      ghc-prim-0.5.3 integer-gmp-1.0.2.0 primitive-0.6.4.0
                      transformers-0.5.6.2 vector-0.12.0.3 word8-0.1.3
orphans: vector-0.12.0.3:Data.Vector.Fusion.Bundle
         transformers-0.5.6.2:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         primitive-0.6.4.0:Control.Monad.Primitive
                         primitive-0.6.4.0:Data.Primitive.Array vector-0.12.0.3:Data.Vector
import  -/  base-4.12.0.0:Control.Applicative 2ae514eb141d45774730765c61bb41c0
import  -/  base-4.12.0.0:Data.Foldable efb37371da929e7bc88d896298d2d979
import  -/  base-4.12.0.0:Data.Maybe 9b76a39e833465c3c5b3c078b431417f
import  -/  base-4.12.0.0:Data.Tuple c719fc29608fe81c10bee9a1bf1e05ff
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Show 838a5d039379d82d9626aae53dfce276
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
import  -/  base-4.12.0.0:Text.Read 87f80fc2538a174aea915dd98f74fc0a
import  -/  ghc-prim-0.5.3:GHC.Classes 0f6fd7d7db53fc48f6e1f01803cc6c9d
import  -/  integer-gmp-1.0.2.0:GHC.Integer.Type 6d87087aea24143d2650f78480d954a3
import  -/  vector-0.12.0.3:Data.Vector 2f7b7a0ec8b90d2d82b017d1a022e0b2
import  -/  word8-0.1.3:Data.Word8 4c659cf945933bcecaaee8b1e623c7ae
8efea5a0223398c29b363294d6d3ff20
  $fApplicativeParser :: GHC.Base.Applicative Solutions.Parser
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Solutions.Parser
                  Solutions.$fFunctorParser
                  Solutions.$fApplicativeParser9
                    `cast`
                  (forall (a :: <*>_N). <a>_R ->_R Sym (Solutions.N:Parser[0] <a>_R))
                  Solutions.$fApplicativeParser8
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Solutions.Parser (a -> b)>_R
                   ->_R <Solutions.Parser a>_R
                   ->_R Sym (Solutions.N:Parser[0] <b>_R))
                  (\ @ a @ b @ c -> Solutions.$fApplicativeParser7 @ c @ b @ a)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N) (c :: <*>_N).
                   <a -> b -> c>_R
                   ->_R <Solutions.Parser a>_R
                   ->_R <Solutions.Parser b>_R
                   ->_R Sym (Solutions.N:Parser[0] <c>_R))
                  (\ @ a @ b -> Solutions.$fApplicativeParser5 @ b @ a)
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Solutions.Parser a>_R
                   ->_R <Solutions.Parser b>_R
                   ->_R Sym (Solutions.N:Parser[0] <b>_R))
                  Solutions.$fApplicativeParser1
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Solutions.Parser a>_R
                   ->_R <Solutions.Parser b>_R
                   ->_R Sym (Solutions.N:Parser[0] <a>_R)) -}
8efea5a0223398c29b363294d6d3ff20
  $fApplicativeParser1 ::
    Solutions.Parser a
    -> Solutions.Parser b
    -> [GHC.Types.Char]
    -> [(a, [GHC.Types.Char])]
  {- Arity: 3, Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ a
                   @ b
                   (x :: Solutions.Parser a)
                   (eta :: Solutions.Parser b)
                   (eta1 :: [GHC.Types.Char]) ->
                 case GHC.Base.map
                        @ (a, [GHC.Types.Char])
                        @ (b -> a, [GHC.Types.Char])
                        (Solutions.$fApplicativeParser4 @ b @ a)
                        (x `cast` (Solutions.N:Parser[0] <a>_R) eta1) of wild {
                   [] -> GHC.Types.[] @ (a, [GHC.Types.Char])
                   : ds ds1
                   -> case ds of wild1 { (,) g rest ->
                      case ds1 of wild2 {
                        [] -> Solutions.$fApplicativeParser3 @ b @ a g eta rest
                        : ipv ipv5 -> Solutions.$fApplicativeParser2 @ a } } }) -}
1d5bdf7228407e64242ebe6bbf7cb752
  $fApplicativeParser2 :: [(b, [GHC.Types.Char])]
  {- Strictness: x -}
8efea5a0223398c29b363294d6d3ff20
  $fApplicativeParser3 ::
    (a -> b)
    -> Solutions.Parser a
    -> [GHC.Types.Char]
    -> [(b, [GHC.Types.Char])]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,C(U)><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Solutions.Parser a)
                   (b5 :: [GHC.Types.Char]) ->
                 GHC.Base.build
                   @ (b, [GHC.Types.Char])
                   (\ @ b1
                      (c :: (b, [GHC.Types.Char]) -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (a, [GHC.Types.Char])
                      @ b1
                      (GHC.Base.mapFB
                         @ (b, [GHC.Types.Char])
                         @ b1
                         @ (a, [GHC.Types.Char])
                         c
                         (\ (b3 :: (a, [GHC.Types.Char])) ->
                          case b3 of wild { (,) a1 a2 -> (f a1, a2) }))
                      n
                      (ds `cast` (Solutions.N:Parser[0] <a>_R) b5))) -}
ae8b1519093166f937f2a7347f9615d9
  $fApplicativeParser4 ::
    (a, [GHC.Types.Char]) -> (b -> a, [GHC.Types.Char])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ b @ a (b3 :: (a, [GHC.Types.Char])) ->
                 case b3 of wild { (,) a1 a2 -> (\ (ds :: b) -> a1, a2) }) -}
8efea5a0223398c29b363294d6d3ff20
  $fApplicativeParser5 ::
    Solutions.Parser a
    -> Solutions.Parser b
    -> [GHC.Types.Char]
    -> [(b, [GHC.Types.Char])]
  {- Arity: 3, Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ b
                   @ a
                   (a1 :: Solutions.Parser a)
                   (a2 :: Solutions.Parser b)
                   (eta :: [GHC.Types.Char]) ->
                 case GHC.Base.map
                        @ (a, [GHC.Types.Char])
                        @ (b -> b, [GHC.Types.Char])
                        (Solutions.$fApplicativeParser6 @ a @ b)
                        (a1 `cast` (Solutions.N:Parser[0] <a>_R) eta) of wild {
                   [] -> GHC.Types.[] @ (b, [GHC.Types.Char])
                   : ds ds1
                   -> case ds of wild1 { (,) g rest ->
                      case ds1 of wild2 {
                        [] -> Solutions.$fApplicativeParser3 @ b @ b g a2 rest
                        : ipv ipv5 -> Solutions.$fApplicativeParser2 @ b } } }) -}
7a0c94de05b4b07246d611d178fdc2be
  $fApplicativeParser6 ::
    (a, [GHC.Types.Char]) -> (b -> b, [GHC.Types.Char])
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (b4 :: (a, [GHC.Types.Char])) ->
                 case b4 of wild { (,) a1 a2 -> (GHC.Base.breakpoint @ b, a2) }) -}
8efea5a0223398c29b363294d6d3ff20
  $fApplicativeParser7 ::
    (a -> b -> c)
    -> Solutions.Parser a
    -> Solutions.Parser b
    -> [GHC.Types.Char]
    -> [(c, [GHC.Types.Char])]
  {- Arity: 4, Strictness: <L,C(U)><C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ c
                   @ b
                   @ a
                   (f1 :: a -> b -> c)
                   (x :: Solutions.Parser a)
                   (eta :: Solutions.Parser b)
                   (eta1 :: [GHC.Types.Char]) ->
                 case GHC.Base.map
                        @ (a, [GHC.Types.Char])
                        @ (b -> c, [GHC.Types.Char])
                        (\ (b3 :: (a, [GHC.Types.Char])) ->
                         case b3 of wild { (,) a1 a2 -> (f1 a1, a2) })
                        (x `cast` (Solutions.N:Parser[0] <a>_R) eta1) of wild {
                   [] -> GHC.Types.[] @ (c, [GHC.Types.Char])
                   : ds ds1
                   -> case ds of wild1 { (,) g rest ->
                      case ds1 of wild2 {
                        [] -> Solutions.$fApplicativeParser3 @ b @ c g eta rest
                        : ipv ipv5 -> Solutions.$fApplicativeParser2 @ c } } }) -}
8efea5a0223398c29b363294d6d3ff20
  $fApplicativeParser8 ::
    Solutions.Parser (a -> b)
    -> Solutions.Parser a
    -> [GHC.Types.Char]
    -> [(b, [GHC.Types.Char])]
  {- Arity: 3, Strictness: <C(S),1*C1(U)><L,1*C1(U)><L,U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: Solutions.Parser (a -> b))
                   (p :: Solutions.Parser a)
                   (input :: [GHC.Types.Char]) ->
                 case f `cast` (Solutions.N:Parser[0] <a -> b>_R) input of wild {
                   [] -> GHC.Types.[] @ (b, [GHC.Types.Char])
                   : ds ds1
                   -> case ds of wild1 { (,) g rest ->
                      case ds1 of wild2 {
                        [] -> Solutions.$fApplicativeParser3 @ a @ b g p rest
                        : ipv ipv5 -> Solutions.$fApplicativeParser2 @ b } } }) -}
e67c3c3187aceecc89b05963440b001a
  $fApplicativeParser9 ::
    a -> [GHC.Types.Char] -> [(a, [GHC.Types.Char])]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (x :: a) (input :: [GHC.Types.Char]) ->
                 GHC.Types.:
                   @ (a, [GHC.Types.Char])
                   (x, input)
                   (GHC.Types.[] @ (a, [GHC.Types.Char]))) -}
8efea5a0223398c29b363294d6d3ff20
  $fFunctorParser :: GHC.Base.Functor Solutions.Parser
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Solutions.Parser
                  Solutions.$fApplicativeParser3
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R <Solutions.Parser a>_R
                   ->_R Sym (Solutions.N:Parser[0] <b>_R))
                  Solutions.$fFunctorParser1
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R <Solutions.Parser b>_R
                   ->_R Sym (Solutions.N:Parser[0] <a>_R)) -}
8efea5a0223398c29b363294d6d3ff20
  $fFunctorParser1 ::
    a
    -> Solutions.Parser b
    -> [GHC.Types.Char]
    -> [(a, [GHC.Types.Char])]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   (z :: a)
                   (ds :: Solutions.Parser b)
                   (b6 :: [GHC.Types.Char]) ->
                 GHC.Base.build
                   @ (a, [GHC.Types.Char])
                   (\ @ b1
                      (c :: (a, [GHC.Types.Char]) -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (b, [GHC.Types.Char])
                      @ b1
                      (GHC.Base.mapFB
                         @ (a, [GHC.Types.Char])
                         @ b1
                         @ (b, [GHC.Types.Char])
                         c
                         (\ (b4 :: (b, [GHC.Types.Char])) ->
                          case b4 of wild { (,) a1 a2 -> (z, a2) }))
                      n
                      (ds `cast` (Solutions.N:Parser[0] <b>_R) b6))) -}
8efea5a0223398c29b363294d6d3ff20
  $fMonadParser :: GHC.Base.Monad Solutions.Parser
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Solutions.Parser
                  Solutions.$fApplicativeParser
                  Solutions.$fMonadParser1
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <Solutions.Parser a>_R
                   ->_R <a -> Solutions.Parser b>_R
                   ->_R Sym (Solutions.N:Parser[0] <b>_R))
                  Solutions.$fMonadParser_$c>>
                  Solutions.$fApplicativeParser9
                    `cast`
                  (forall (a :: <*>_N). <a>_R ->_R Sym (Solutions.N:Parser[0] <a>_R))
                  (\ @ a ->
                   GHC.Err.errorWithoutStackTrace
                     @ 'GHC.Types.LiftedRep
                     @ (Solutions.Parser a)) -}
8efea5a0223398c29b363294d6d3ff20
  $fMonadParser1 ::
    Solutions.Parser a
    -> (a -> Solutions.Parser b)
    -> [GHC.Types.Char]
    -> [(b, [GHC.Types.Char])]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S),1*C1(U)><L,C(C1(U))><L,U>,
     Unfolding: (\ @ a
                   @ b
                   (p :: Solutions.Parser a)
                   (f :: a -> Solutions.Parser b)
                   (input :: [GHC.Types.Char]) ->
                 case p `cast` (Solutions.N:Parser[0] <a>_R) input of wild {
                   [] -> GHC.Types.[] @ (b, [GHC.Types.Char])
                   : ds ds1
                   -> case ds of wild1 { (,) x rest ->
                      case ds1 of wild2 {
                        [] -> (f x) `cast` (Solutions.N:Parser[0] <b>_R) rest
                        : ipv ipv5
                        -> letrec {
                             go :: [(a, [GHC.Types.Char])] -> [(b, [GHC.Types.Char])]
                               {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds2 :: [(a, [GHC.Types.Char])]) ->
                               case ds2 of wild3 {
                                 [] -> GHC.Types.[] @ (b, [GHC.Types.Char])
                                 : y ys
                                 -> GHC.Base.++
                                      @ (b, [GHC.Types.Char])
                                      ((f (case y of wild4 { (,) x1 ds3 -> x1 }))
                                         `cast`
                                       (Solutions.N:Parser[0] <b>_R)
                                         (case y of wild4 { (,) ds3 y1 -> y1 }))
                                      (go ys) }
                           } in
                           go wild } } }) -}
8efea5a0223398c29b363294d6d3ff20
  $fMonadParser_$c>> ::
    Solutions.Parser a -> Solutions.Parser b -> Solutions.Parser b
  {- Arity: 3, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,C(U)><L,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a @ b (m1 :: Solutions.Parser a) (k :: Solutions.Parser b) ->
                 Solutions.$fMonadParser1 @ a @ b m1 (\ (ds :: a) -> k))
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Solutions.Parser a>_R
                 ->_R <Solutions.Parser b>_R
                 ->_R Sym (Solutions.N:Parser[0] <b>_R)) -}
2f94593ffd5ce764ca5e3a8616caff63
  $fShowBin :: GHC.Show.Show a => GHC.Show.Show (Solutions.Bin a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ a (v :: GHC.Show.Show a).
                  @ (Solutions.Bin a)
                  (Solutions.$fShowBin_$cshowsPrec @ a v)
                  (Solutions.$fShowBin_$cshow @ a v)
                  (Solutions.$fShowBin_$cshowList @ a v) -}
57871a18879e816c56f09c063772e8d6
  $fShowBin1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
2f94593ffd5ce764ca5e3a8616caff63
  $fShowBin_$cshow ::
    GHC.Show.Show a => Solutions.Bin a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Solutions.Bin a) ->
                 Solutions.$fShowBin_$cshowsPrec
                   @ a
                   $dShow
                   Solutions.$fShowBin1
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2f94593ffd5ce764ca5e3a8616caff63
  $fShowBin_$cshowList ::
    GHC.Show.Show a => [Solutions.Bin a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Solutions.Bin a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Solutions.Bin a)
                   (Solutions.$fShowBin_$cshowsPrec @ a $dShow Solutions.$fShowBin1)
                   ls
                   s) -}
2f94593ffd5ce764ca5e3a8616caff63
  $fShowBin_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Solutions.Bin a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C(U))),A,A)><L,1*U(U)><S,1*U> -}
7b258b2f8fa7261f8f9f1317d21319b3
  $tc'Leaf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10538183299790483651##
                   14234194499010362284##
                   Solutions.$trModule
                   Solutions.$tc'Leaf2
                   1#
                   Solutions.$tc'Leaf1) -}
5cdd36f7555fb531b29782554ba52dc5
  $tc'Leaf1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
e1b7752c3568b2eaab87b6c54dedee08
  $tc'Leaf2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Solutions.$tc'Leaf3) -}
0b0241ed863356813e5d73f243268469
  $tc'Leaf3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Leaf"#) -}
8cfe2066127c6dd3086a4ab19059bebb
  $tc'Node :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4575288333681519937##
                   17254170630778433109##
                   Solutions.$trModule
                   Solutions.$tc'Node2
                   1#
                   Solutions.$tc'Node1) -}
67209ab2547ad035518c96cacee7ca42
  $tc'Node1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
893bf15fca169cb93c076ead7bc72753
  $tc'Node2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Solutions.$tc'Node3) -}
07be29f693efae6ea2e99221435f23aa
  $tc'Node3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Node"#) -}
1f99b6cfbee00d518d3aff9a49cac9a5
  $tc'P :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   922070229752038412##
                   2655822038131553987##
                   Solutions.$trModule
                   Solutions.$tc'P2
                   1#
                   Solutions.$tc'P1) -}
34aac99a76b9334b8657ab283387d562
  $tc'P1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
3ded61beca7ad1edd7666ba80dad9a3c
  $tc'P2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Solutions.$tc'P3) -}
0997fd8ce28a50bbee3fe4e9a62e0a4e
  $tc'P3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'P"#) -}
cdb52bf1226677fab9065986fe7291e8
  $tcBin :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1070240374737696448##
                   9067082446942254621##
                   Solutions.$trModule
                   Solutions.$tcBin1
                   0#
                   GHC.Types.krep$*Arr*) -}
5e76135008b3244ff0e1ed18bd87e6d7
  $tcBin1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Solutions.$tcBin2) -}
2599d3b820102d4a09ec064107147d9e
  $tcBin2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Bin"#) -}
c8e1434dcaf78a2fcf460d3803259c68
  $tcParser :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6192183401926590321##
                   6654825417121245310##
                   Solutions.$trModule
                   Solutions.$tcParser1
                   0#
                   GHC.Types.krep$*Arr*) -}
03fcd845b6314dce2685bfd814ab84ff
  $tcParser1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Solutions.$tcParser2) -}
1f90e8e5cc79fb4ca96a6b0a2de023e3
  $tcParser2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Parser"#) -}
ad939c1f70a22567bcfcf5a7365d1ec6
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Solutions.$trModule3
                   Solutions.$trModule1) -}
d386ade52652c41954380d8a293c25b6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Solutions.$trModule2) -}
b86b0255e0a726484acf2f85eecfc046
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Solutions"#) -}
02783df89af988b2dd9b5d37df7c2619
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Solutions.$trModule4) -}
54208de2adeb93dd24d393e47f481436
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
f9e4a7142261408df44379d9b6656879
  $wfoldlM_loop ::
    GHC.Types.SPEC
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.MutableArray# GHC.Prim.RealWorld GHC.Types.Int
    -> GHC.Prim.Int#
    -> [GHC.Types.Int]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Vector.Vector GHC.Types.Int #)
  {- Arity: 7, Strictness: <S,1*U><L,U><L,U><S,U><L,U><S,1*U><S,U>,
     Inline: [2] -}
a193296a9d4dfad437dcbe2387f381eb
  $winsert ::
    GHC.Classes.Ord a =>
    a -> Solutions.Bin a -> (# a, Solutions.Bin a, Solutions.Bin a #)
  {- Arity: 3,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A)><L,U><S,1*U>,
     Inline: [2] -}
f46091c956a75b95b16b04fb76cb0692
  $wmissingNumber :: [GHC.Types.Int] -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,U>, Inline: [2],
     Unfolding: (\ (w :: [GHC.Types.Int]) ->
                 case GHC.List.$wlenAcc @ GHC.Types.Int w 0# of ww2 { DEFAULT ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Vector GHC.Types.Int #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           n :: GHC.Prim.Int# = GHC.Prim.+# ww2 1#
                         } in
                         let {
                           $j :: GHC.Prim.Int#
                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                       Data.Vector.Vector GHC.Types.Int #)
                             <join 1> {- Arity: 1, Strictness: <S,U> -}
                           = \ (n# :: GHC.Prim.Int#)[OneShot] ->
                             case GHC.Prim.newArray#
                                    @ GHC.Types.Int
                                    @ (Control.Monad.Primitive.PrimState
                                         (GHC.ST.ST GHC.Prim.RealWorld))
                                    n#
                                    (Data.Vector.Mutable.uninitialised @ GHC.Types.Int)
                                    s1
                                      `cast`
                                    (GHC.Prim.State#
                                       (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                 (Nth:0
                                                      (Nth:2
                                                           (<GHC.Prim.State# GHC.Prim.RealWorld>_R
                                                            ->_R ((#,#)
                                                                    <'GHC.Types.TupleRep '[]>_R
                                                                    <'GHC.Types.LiftedRep>_R
                                                                    <GHC.Prim.State#
                                                                       GHC.Prim.RealWorld>_R
                                                                    (Data.Vector.Generic.Base.Mutable
                                                                       <Data.Vector.Vector>_N
                                                                       (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                            <GHC.Prim.RealWorld>_N)
                                                                       <GHC.Types.Int>_N)_R)_R))))))_R of ds1 { (#,#) ipv ipv5 ->
                             let {
                               exit :: GHC.Prim.Int#
                                       -> GHC.Prim.State# GHC.Prim.RealWorld
                                       -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                             Data.Vector.Vector GHC.Types.Int #)
                                 <join 2> {- Arity: 2, Strictness: <L,U><S,U> -}
                               = \ (ww :: GHC.Prim.Int#)[OneShot]
                                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                 case GHC.Prim.unsafeFreezeArray#
                                        @ (Control.Monad.Primitive.PrimState
                                             (GHC.ST.ST GHC.Prim.RealWorld))
                                        @ GHC.Types.Int
                                        ipv5
                                        w1
                                          `cast`
                                        (GHC.Prim.State#
                                           (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                     (Nth:0
                                                          (Nth:2
                                                               (Nth:3
                                                                    (<GHC.Prim.State#
                                                                        GHC.Prim.RealWorld>_R
                                                                     ->_R ((#,#)
                                                                             <'GHC.Types.TupleRep
                                                                                '[]>_R
                                                                             <'GHC.Types.LiftedRep>_R
                                                                             <GHC.Prim.State#
                                                                                GHC.Prim.RealWorld>_R
                                                                             (Data.Vector.Generic.Base.Mutable
                                                                                <Data.Vector.Vector>_N
                                                                                (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                                          <GHC.Prim.RealWorld>_N))
                                                                                <GHC.Types.Int>_N)_R)_R)))))))_R of ds2 { (#,#) ipv6 ipv7 ->
                                 (# ipv6
                                      `cast`
                                    (GHC.Prim.State#
                                       (Control.Monad.Primitive.D:R:PrimStateST[0]
                                            <GHC.Prim.RealWorld>_N))_R,
                                    Data.Vector.Vector @ GHC.Types.Int 0# ww ipv7 #) }
                             } in
                             letrec {
                               $wfoldlM'_loop :: GHC.Types.SPEC
                                                 -> GHC.Prim.Int#
                                                 -> GHC.Prim.Int#
                                                 -> GHC.Prim.State# GHC.Prim.RealWorld
                                                 -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                       Data.Vector.Vector GHC.Types.Int #)
                                 <join 4> {- Arity: 4, Strictness: <S,1*U><S,U><S,U><S,U>,
                                             Inline: [2] -}
                               = \ (w1 :: GHC.Types.SPEC)
                                   (ww :: GHC.Prim.Int#)
                                   (ww1 :: GHC.Prim.Int#)
                                   (w2 :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                 case w1 of ds5 { DEFAULT ->
                                 case GHC.Prim.<# ww1 n of lwild {
                                   DEFAULT -> exit ww w2
                                   1#
                                   -> case GHC.Prim.writeArray#
                                             @ (Control.Monad.Primitive.PrimState
                                                  (GHC.ST.ST GHC.Prim.RealWorld))
                                             @ GHC.Types.Int
                                             ipv5
                                             ww
                                             (GHC.Types.I# (GHC.Prim.+# ww1 1#))
                                             w2
                                               `cast`
                                             (GHC.Prim.State#
                                                (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                          <GHC.Prim.RealWorld>_N)))_R of s'# { DEFAULT ->
                                      $wfoldlM'_loop
                                        GHC.Types.SPEC
                                        (GHC.Prim.+# ww 1#)
                                        (GHC.Prim.+# ww1 1#)
                                        s'#
                                          `cast`
                                        (GHC.Prim.State#
                                           (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                <GHC.Prim.RealWorld>_N))_R } } }
                             } in
                             $wfoldlM'_loop
                               GHC.Types.SPEC
                               0#
                               0#
                               ipv
                                 `cast`
                               (GHC.Prim.State#
                                  (Control.Monad.Primitive.D:R:PrimStateST[0]
                                       (Nth:0
                                            (Nth:2
                                                 (Nth:3
                                                      (<GHC.Prim.State# GHC.Prim.RealWorld>_R
                                                       ->_R ((#,#)
                                                               <'GHC.Types.TupleRep '[]>_R
                                                               <'GHC.Types.LiftedRep>_R
                                                               <GHC.Prim.State#
                                                                  GHC.Prim.RealWorld>_R
                                                               (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                                (GHC.ST.ST
                                                                                                                   GHC.Prim.RealWorld)>_N <GHC.Types.Int>_N))_R))))))_R }
                         } in
                         case GHC.Prim.<=# n 0# of lwild {
                           DEFAULT -> $j n 1# -> $j 0# }) of ds1 { (#,#) ipv5 ipv6 ->
                 case ipv6 of ww { Data.Vector.Vector ww1 ww3 ww4 ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.Vector.Vector GHC.Types.Int #)
                        (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         case GHC.Prim.newArray#
                                @ GHC.Types.Int
                                @ (Control.Monad.Primitive.PrimState
                                     (GHC.ST.ST GHC.Prim.RealWorld))
                                0#
                                (Data.Vector.Mutable.uninitialised @ GHC.Types.Int)
                                s1
                                  `cast`
                                (GHC.Prim.State#
                                   (Sym (Control.Monad.Primitive.D:R:PrimStateST[0]
                                             (Nth:0
                                                  (Nth:2
                                                       (<GHC.Prim.State# GHC.Prim.RealWorld>_R
                                                        ->_R ((#,#)
                                                                <'GHC.Types.TupleRep '[]>_R
                                                                <'GHC.Types.LiftedRep>_R
                                                                <GHC.Prim.State#
                                                                   GHC.Prim.RealWorld>_R
                                                                (Data.Vector.Generic.Base.Mutable
                                                                   <Data.Vector.Vector>_N
                                                                   (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                        <GHC.Prim.RealWorld>_N)
                                                                   <GHC.Types.Int>_N)_R)_R))))))_R of ds2 { (#,#) ipv ipv7 ->
                         Solutions.$wfoldlM_loop
                           GHC.Types.SPEC
                           0#
                           0#
                           ipv7
                             `cast`
                           (GHC.Prim.MutableArray#
                              (Nth:0
                                   (Nth:3
                                        (Nth:3
                                             (<GHC.Prim.State# GHC.Prim.RealWorld>_R
                                              ->_R ((#,#)
                                                      <'GHC.Types.TupleRep '[]>_R
                                                      <'GHC.Types.LiftedRep>_R
                                                      <GHC.Prim.State# GHC.Prim.RealWorld>_R
                                                      (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                       (GHC.ST.ST
                                                                                                          GHC.Prim.RealWorld)>_N <GHC.Types.Int>_N))_R)) ; Sub (Data.Vector.D:R:MutableVector[0]) (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                                                                                                                                                       <GHC.Prim.RealWorld>_N) <GHC.Types.Int>_N))
                              (Nth:1
                                   (Nth:3
                                        (Nth:3
                                             (<GHC.Prim.State# GHC.Prim.RealWorld>_R
                                              ->_R ((#,#)
                                                      <'GHC.Types.TupleRep '[]>_R
                                                      <'GHC.Types.LiftedRep>_R
                                                      <GHC.Prim.State# GHC.Prim.RealWorld>_R
                                                      (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                       (GHC.ST.ST
                                                                                                          GHC.Prim.RealWorld)>_N <GHC.Types.Int>_N))_R)) ; Sub (Data.Vector.D:R:MutableVector[0]) (Control.Monad.Primitive.D:R:PrimStateST[0]
                                                                                                                                                                                                       <GHC.Prim.RealWorld>_N) <GHC.Types.Int>_N)))_R
                           0#
                           w
                           ipv
                             `cast`
                           (GHC.Prim.State#
                              (Control.Monad.Primitive.D:R:PrimStateST[0]
                                   (Nth:0
                                        (Nth:2
                                             (Nth:3
                                                  (<GHC.Prim.State# GHC.Prim.RealWorld>_R
                                                   ->_R ((#,#)
                                                           <'GHC.Types.TupleRep '[]>_R
                                                           <'GHC.Types.LiftedRep>_R
                                                           <GHC.Prim.State# GHC.Prim.RealWorld>_R
                                                           (Sub (Sym (Data.Vector.D:R:MutableVector[0])) <Control.Monad.Primitive.PrimState
                                                                                                            (GHC.ST.ST
                                                                                                               GHC.Prim.RealWorld)>_N <GHC.Types.Int>_N))_R))))))_R }) of ds2 { (#,#) ipv7 ipv8 ->
                 case ipv8 of ww5 { Data.Vector.Vector ww6 ww7 ww8 ->
                 Solutions.$wmissingNumber' ww1 ww3 ww4 ww6 ww7 ww8 } } } } }) -}
ab5c0cf760d67de2411d8d0c18f6da35
  $wmissingNumber' ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Array# GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Array# GHC.Types.Int
    -> GHC.Prim.Int#
  {- Arity: 6, Strictness: <L,U><S,U><L,U><L,U><S,1*U><L,U>,
     Inline: [2] -}
2c0a5680370e8db83ba3c2410cb7e257
  $wonlyJust ::
    GHC.Maybe.Maybe GHC.Word.Word8
    -> GHC.Maybe.Maybe GHC.Word.Word8
    -> GHC.Maybe.Maybe GHC.Word.Word8
    -> GHC.Maybe.Maybe GHC.Word.Word8
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*U>, Inline: [2],
     Unfolding: (\ (ww :: GHC.Maybe.Maybe GHC.Word.Word8)
                   (ww1 :: GHC.Maybe.Maybe GHC.Word.Word8)
                   (ww2 :: GHC.Maybe.Maybe GHC.Word.Word8)
                   (ww3 :: GHC.Maybe.Maybe GHC.Word.Word8) ->
                 case ww of wild {
                   GHC.Maybe.Nothing -> GHC.Types.False
                   GHC.Maybe.Just ipv
                   -> case ww1 of wild1 {
                        GHC.Maybe.Nothing -> GHC.Types.False
                        GHC.Maybe.Just ipv5
                        -> case ww2 of wild2 {
                             GHC.Maybe.Nothing -> GHC.Types.False
                             GHC.Maybe.Just ipv6
                             -> Data.Maybe.isJust @ GHC.Word.Word8 ww3 } } }) -}
2f94593ffd5ce764ca5e3a8616caff63
  data Bin a = Leaf | Node a (Solutions.Bin a) (Solutions.Bin a)
8b9ece5b1f307a7d1f1cef6ea5bd88fc
  type IPv4 =
    (GHC.Word.Word8, GHC.Word.Word8, GHC.Word.Word8, GHC.Word.Word8)
7038813781de85c5398c6cd9591aa721
  type IPv4' =
    (GHC.Maybe.Maybe GHC.Word.Word8, GHC.Maybe.Maybe GHC.Word.Word8,
     GHC.Maybe.Maybe GHC.Word.Word8, GHC.Maybe.Maybe GHC.Word.Word8)
8efea5a0223398c29b363294d6d3ff20
  newtype Parser a = P ([GHC.Types.Char] -> [(a, [GHC.Types.Char])])
1468a637c47c17e919e4b2fcaf6d1684
  insert ::
    GHC.Classes.Ord a => a -> Solutions.Bin a -> Solutions.Bin a
  {- Arity: 3,
     Strictness: <L,U(U(C(C1(U)),A),A,C(C1(U)),A,C(C1(U)),A,A,A)><L,U><S,1*U>m2,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Ord a)
                   (w1 :: a)
                   (w2 :: Solutions.Bin a) ->
                 case Solutions.$winsert @ a w w1 w2 of ww { (#,,#) ww1 ww2 ww3 ->
                 Solutions.Node @ a ww1 ww2 ww3 }) -}
87fbb6e1c9f0975e879fa5a35f24d070
  ipv1 :: [GHC.Types.Char] -> [(Solutions.IPv4', [GHC.Types.Char])]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (input :: [GHC.Types.Char]) ->
                 case Solutions.ipv3 input of wild {
                   [] -> GHC.Types.[] @ (Solutions.IPv4', [GHC.Types.Char])
                   : ds ds1
                   -> case ds of wild1 { (,) x rest ->
                      case ds1 of wild2 {
                        [] -> Solutions.ipv2 x rest
                        : ipv ipv5 -> Solutions.ipv4_go wild } } }) -}
b624483f2a402c657f3a2699f6bf97b8
  ipv2 ::
    GHC.Maybe.Maybe GHC.Word.Word8
    -> [GHC.Types.Char] -> [(Solutions.IPv4', [GHC.Types.Char])]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
3adfcdfa2f6b1b346ee4382575ff9817
  ipv3 ::
    [GHC.Types.Char]
    -> [(GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (input :: [GHC.Types.Char]) ->
                 case input of wild {
                   []
                   -> GHC.Types.[]
                        @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                   : x1 ds
                   -> case ds of wild1 {
                        []
                        -> GHC.Types.:
                             @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                             (Solutions.myReadWord8
                                (GHC.Types.: @ GHC.Types.Char x1 (GHC.Types.[] @ GHC.Types.Char)),
                              GHC.Types.[] @ GHC.Types.Char)
                             (GHC.Types.[] @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char]))
                        : x2 ds1
                        -> case ds1 of wild2 {
                             []
                             -> GHC.Types.:
                                  @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                                  (Solutions.myReadWord8
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        x1
                                        (GHC.Types.[] @ GHC.Types.Char)),
                                   GHC.Types.: @ GHC.Types.Char x2 (GHC.Types.[] @ GHC.Types.Char))
                                  (GHC.Types.:
                                     @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                                     (Solutions.myReadWord8 wild, GHC.Types.[] @ GHC.Types.Char)
                                     (GHC.Types.[]
                                        @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])))
                             : x3 ds2
                             -> case ds2 of wild3 {
                                  []
                                  -> GHC.Types.:
                                       @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                                       (Solutions.myReadWord8
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             x1
                                             (GHC.Types.[] @ GHC.Types.Char)),
                                        GHC.Types.:
                                          @ GHC.Types.Char
                                          x2
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             x3
                                             (GHC.Types.[] @ GHC.Types.Char)))
                                       (GHC.Types.:
                                          @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                                          (Solutions.myReadWord8
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                x1
                                                (GHC.Types.:
                                                   @ GHC.Types.Char
                                                   x2
                                                   (GHC.Types.[] @ GHC.Types.Char))),
                                           GHC.Types.:
                                             @ GHC.Types.Char
                                             x3
                                             (GHC.Types.[] @ GHC.Types.Char))
                                          (GHC.Types.:
                                             @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                                             (Solutions.myReadWord8 wild,
                                              GHC.Types.[] @ GHC.Types.Char)
                                             (GHC.Types.[]
                                                @ (GHC.Maybe.Maybe GHC.Word.Word8,
                                                   [GHC.Types.Char]))))
                                  : ipv ipv5
                                  -> GHC.Types.:
                                       @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                                       (Solutions.myReadWord8
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             x1
                                             (GHC.Types.[] @ GHC.Types.Char)),
                                        wild1)
                                       (GHC.Types.:
                                          @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                                          (Solutions.myReadWord8
                                             (GHC.Types.:
                                                @ GHC.Types.Char
                                                x1
                                                (GHC.Types.:
                                                   @ GHC.Types.Char
                                                   x2
                                                   (GHC.Types.[] @ GHC.Types.Char))),
                                           wild2)
                                          (GHC.Types.:
                                             @ (GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])
                                             (Solutions.myReadWord8
                                                (GHC.Types.:
                                                   @ GHC.Types.Char
                                                   x1
                                                   (GHC.Types.:
                                                      @ GHC.Types.Char
                                                      x2
                                                      (GHC.Types.:
                                                         @ GHC.Types.Char
                                                         x3
                                                         (GHC.Types.[] @ GHC.Types.Char)))),
                                              wild3)
                                             (GHC.Types.[]
                                                @ (GHC.Maybe.Maybe GHC.Word.Word8,
                                                   [GHC.Types.Char])))) } } } }) -}
d3cf72fe17bcf46c1894efe961d2d56c
  ipv4 :: Solutions.Parser Solutions.IPv4'
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Solutions.ipv1
                  `cast`
                (Sym (Solutions.N:Parser[0] <Solutions.IPv4'>_R)) -}
e47636cfd4d2fd084d1b67202ef2f768
  ipv4_go ::
    [(GHC.Maybe.Maybe GHC.Word.Word8, [GHC.Types.Char])]
    -> [(Solutions.IPv4', [GHC.Types.Char])]
  {- Arity: 1, Strictness: <S,1*U> -}
9967f632d787bfed6653480c08a9ead4
  missingNumber :: [GHC.Types.Int] -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,U>m, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [GHC.Types.Int]) ->
                 case Solutions.$wmissingNumber w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
82bb0910f455e788e653cdbb5f886dd5
  missingNumber' ::
    Data.Vector.Vector GHC.Types.Int
    -> Data.Vector.Vector GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, Strictness: <S(SSS),1*U(U,U,U)><S(SSS),1*U(U,1*U,U)>m,
     Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Data.Vector.Vector GHC.Types.Int)
                   (w1 :: Data.Vector.Vector GHC.Types.Int) ->
                 case w of ww { Data.Vector.Vector ww1 ww2 ww3 ->
                 case w1 of ww4 { Data.Vector.Vector ww5 ww6 ww7 ->
                 case Solutions.$wmissingNumber'
                        ww1
                        ww2
                        ww3
                        ww5
                        ww6
                        ww7 of ww8 { DEFAULT ->
                 GHC.Types.I# ww8 } } }) -}
c0619a1aca400582f799555e47b6bf44
  myReadWord1 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
c54d74387a34aaae2904e54cb8c633fd
  myReadWord10 ::
    Text.ParserCombinators.ReadP.P GHC.Integer.Type.Integer
  {- Unfolding: (GHC.Read.$fReadInteger_$sreadNumber
                   GHC.Read.$fReadInteger2
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Integer.Type.Integer
                   (Text.Read.readEither7 @ GHC.Integer.Type.Integer)) -}
f9b72da08e0f9fdcc70c1bd75ba17dbc
  myReadWord2 :: GHC.Word.Word8
  {- Strictness: x -}
7a5cebc8d129b6fde163bcdeac9bee30
  myReadWord3 :: GHC.Word.Word8
  {- Strictness: x -}
3c8124331825127d1b75622342becb3c
  myReadWord4 :: Text.ParserCombinators.ReadP.P GHC.Word.Word8
  {- Strictness: m2,
     Unfolding: (Text.ParserCombinators.ReadP.Look
                   @ GHC.Word.Word8
                   Solutions.myReadWord5) -}
0423377cc384f9859a5f57de0e72558c
  myReadWord5 ::
    GHC.Base.String -> Text.ParserCombinators.ReadP.P GHC.Word.Word8
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 case Solutions.myReadWord8_go
                        (GHC.Read.$fReadWord8_go
                           (Text.ParserCombinators.ReadP.run
                              @ GHC.Types.Int
                              Solutions.myReadWord6
                              s)) of wild {
                   [] -> Text.ParserCombinators.ReadP.Fail @ GHC.Word.Word8
                   : ipv ipv5
                   -> Text.ParserCombinators.ReadP.Final @ GHC.Word.Word8 wild }) -}
cd19b4a803e6a6c96ed980b35f725b03
  myReadWord6 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: (GHC.Read.$fReadInt_$sreadNumber
                   GHC.Read.$fReadInt2
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Int
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ GHC.Types.Int)) -}
234d0773fb6e836dd118eabacb7a870c
  myReadWord7 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (255) -}
ec283d16848e01d5b694792fb901689e
  myReadWord8 :: GHC.Base.String -> GHC.Maybe.Maybe GHC.Word.Word8
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (str :: GHC.Base.String) ->
                 case Text.Read.readEither8
                        @ GHC.Integer.Type.Integer
                        (Text.ParserCombinators.ReadP.run
                           @ GHC.Integer.Type.Integer
                           Solutions.myReadWord10
                           str) of wild {
                   []
                   -> case Solutions.myReadWord9
                      ret_ty (GHC.Maybe.Maybe GHC.Word.Word8)
                      of {}
                   : x ds
                   -> case ds of wild1 {
                        []
                        -> case GHC.Integer.Type.gtInteger#
                                  x
                                  Solutions.myReadWord7 of wild2 {
                             DEFAULT
                             -> GHC.Maybe.Just
                                  @ GHC.Word.Word8
                                  (case Text.Read.readEither8
                                          @ GHC.Word.Word8
                                          (Text.ParserCombinators.ReadP.run
                                             @ GHC.Word.Word8
                                             Solutions.myReadWord4
                                             str) of wild3 {
                                     [] -> Solutions.myReadWord3
                                     : x1 ds1
                                     -> case ds1 of wild4 {
                                          [] -> x1 : ipv ipv5 -> Solutions.myReadWord2 } })
                             1# -> GHC.Maybe.Nothing @ GHC.Word.Word8 }
                        : ipv ipv5
                        -> case Solutions.myReadWord1
                           ret_ty (GHC.Maybe.Maybe GHC.Word.Word8)
                           of {} } }) -}
ea2d39be515cf55a1884e3fcc1a345f8
  myReadWord8_go ::
    [(GHC.Word.Word8, GHC.Base.String)]
    -> [(GHC.Word.Word8, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
4294b2ff5fc7bab0346ab01006c9ffe2
  myReadWord9 :: GHC.Integer.Type.Integer
  {- Strictness: x -}
79be359e8c855515802640020292cb55
  onlyJust :: Solutions.IPv4' -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SLLL),1*U(1*U,1*U,1*U,1*U)>, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Solutions.IPv4') ->
                 case w of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 Solutions.$wonlyJust ww1 ww2 ww3 ww4 }) -}
9d8bc45ed95f1bfb3984473490bbfd69
  parse ::
    Solutions.Parser a -> [GHC.Types.Char] -> [(a, [GHC.Types.Char])]
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a (ds :: Solutions.Parser a) (str :: [GHC.Types.Char]) ->
                 ds `cast` (Solutions.N:Parser[0] <a>_R) str) -}
3650e332912578d4d230f9c86036f6b7
  possibleAddresses :: GHC.Base.String -> [Solutions.IPv4]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (input :: GHC.Base.String) ->
                 Solutions.possibleAddresses_go (Solutions.ipv1 input)) -}
9402d77526e081e7aef287fdb69940c1
  possibleAddresses' :: GHC.Base.String -> [Solutions.IPv4']
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (input :: GHC.Base.String) ->
                 Solutions.possibleAddresses'_go (Solutions.ipv1 input)) -}
cb60e67b0c96b07be0c530592f1c7aa0
  possibleAddresses'_go ::
    [(Solutions.IPv4', [GHC.Types.Char])]
    -> [(GHC.Maybe.Maybe GHC.Word.Word8,
         GHC.Maybe.Maybe GHC.Word.Word8, GHC.Maybe.Maybe GHC.Word.Word8,
         GHC.Maybe.Maybe GHC.Word.Word8)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a377a77d738ffa29f678f47e84a402d9
  possibleAddresses_go ::
    [(Solutions.IPv4', [GHC.Types.Char])]
    -> [(GHC.Word.Word8, GHC.Word.Word8, GHC.Word.Word8,
         GHC.Word.Word8)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
fc2c1b8f72882e9c09eca4f984daaa9f
  unmaybeIPv1 :: GHC.Word.Word8
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Word.W8# 0##) -}
f67b62e7c0796d8c1db65a629cd032e6
  unmaybeIPv4 :: Solutions.IPv4' -> Solutions.IPv4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U,1*U,1*U,1*U)>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Solutions.IPv4') ->
                 case w of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 (case ww1 of wild {
                    GHC.Maybe.Nothing -> Solutions.unmaybeIPv1 GHC.Maybe.Just x -> x },
                  case ww2 of wild {
                    GHC.Maybe.Nothing -> Solutions.unmaybeIPv1 GHC.Maybe.Just x -> x },
                  case ww3 of wild {
                    GHC.Maybe.Nothing -> Solutions.unmaybeIPv1 GHC.Maybe.Just x -> x },
                  case ww4 of wild {
                    GHC.Maybe.Nothing -> Solutions.unmaybeIPv1
                    GHC.Maybe.Just x -> x }) }) -}
d66a796a1b987377cea71662d1289000
  word8 :: Solutions.Parser (GHC.Maybe.Maybe GHC.Word.Word8)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Solutions.ipv3
                  `cast`
                (Sym (Solutions.N:Parser[0] <GHC.Maybe.Maybe GHC.Word.Word8>_R)) -}
instance GHC.Base.Applicative [Solutions.Parser]
  = Solutions.$fApplicativeParser
instance GHC.Base.Functor [Solutions.Parser]
  = Solutions.$fFunctorParser
instance GHC.Base.Monad [Solutions.Parser]
  = Solutions.$fMonadParser
instance GHC.Show.Show [Solutions.Bin] = Solutions.$fShowBin
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

